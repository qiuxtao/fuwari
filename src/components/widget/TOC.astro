---
import type { MarkdownHeading } from "astro";
import TOCList from "./TOCList.astro";

interface Props {
	class?: string;
	headings: MarkdownHeading[];
}

let { headings = [] } = Astro.props;

const className = Astro.props.class;

const removeTailingHash = (text: string) => {
	let lastIndexOfHash = text.lastIndexOf("#");
	if (lastIndexOfHash !== text.length - 1) {
		return text;
	}
	return text.substring(0, lastIndexOfHash);
};

interface TocItem extends MarkdownHeading {
	children: TocItem[];
}

function buildToc(headings: MarkdownHeading[]): TocItem[] {
	const toc: TocItem[] = [];
	const parentStack: TocItem[] = [];

	headings.forEach((h) => {
		const item: TocItem = { ...h, text: removeTailingHash(h.text), children: [] };
		
		while (parentStack.length > 0 && parentStack[parentStack.length - 1].depth >= item.depth) {
			parentStack.pop();
		}

		if (parentStack.length > 0) {
			parentStack[parentStack.length - 1].children.push(item);
		} else {
			toc.push(item);
		}
		parentStack.push(item);
	});
	return toc;
}

const toc = buildToc(headings);
---
<table-of-contents class:list={[className, "group block relative z-0"]} id="toc-container">
    <div class="relative" style="mask-image: none !important; -webkit-mask-image: none !important;">
        <div id="toc-content">
            <TOCList items={toc} />
        </div>
        <div id="active-indicator" class:list={[{'hidden': headings.length == 0}, 
            "-z-10 absolute left-0 right-0 rounded-lg transition-all duration-200 " +
            "bg-[var(--toc-btn-hover)] border-2 border-transparent " + 
            "group-hover:bg-transparent group-hover:border-[var(--toc-btn-active)] group-hover:border-dashed"
        ]}></div>
    </div>
</table-of-contents>

<script>
function generateTocHTML(items, level = 0) {
    if (!items || items.length === 0) return '';
    let html = `<div class="flex flex-col gap-0">`;
    items.forEach((item, index) => {
        const paddingLeft = `calc(0.75rem + ${level * 1}rem)`;
        let badgeContent = '';
        let badgeClass = "transition w-5 h-5 shrink-0 rounded-md text-xs flex items-center justify-center font-bold mt-[0.125rem]";
        if (level === 0) {
            badgeClass += " bg-[var(--toc-badge-bg)] text-[var(--btn-content)]";
            badgeContent = `${index + 1}`;
        } else if (level === 1) {
            badgeContent = `<div class="transition w-1.5 h-1.5 rounded-[0.1875rem] bg-[var(--toc-badge-bg)]"></div>`;
        } else {
            badgeContent = `<div class="transition w-1 h-1 rounded-sm bg-black/5 dark:bg-white/10"></div>`;
        }
        let textClass = "transition text-sm break-words leading-tight mt-[0.125rem]";
        if (level === 0 || level === 1) textClass += " text-50";
        else textClass += " text-30";

        html += `
            <div class="flex flex-col relative group-item">
                <a href="#${item.slug}" 
                   class="flex gap-2 items-start relative transition w-full min-h-9 rounded-lg hover:bg-[var(--toc-btn-hover)] active:bg-[var(--toc-btn-active)] py-2 pr-2"
                   style="padding-left: ${paddingLeft}">
                    <div class="${badgeClass}">${badgeContent}</div>
                    <div class="${textClass}">${item.text}</div>
                </a>
                ${generateTocHTML(item.children, level + 1)}
            </div>
        `;
    });
    html += `</div>`;
    return html;
}

function buildTocData(headings) {
    const toc = [];
    const parentStack = [];
    headings.forEach((h) => {
        let text = h.text;
        if (text.endsWith('#')) text = text.substring(0, text.length - 1);
        const item = { ...h, text: text, children: [] };
        while (parentStack.length > 0 && parentStack[parentStack.length - 1].depth >= item.depth) {
            parentStack.pop();
        }
        if (parentStack.length > 0) {
            parentStack[parentStack.length - 1].children.push(item);
        } else {
            toc.push(item);
        }
        parentStack.push(item);
    });
    return toc;
}

class TableOfContents extends HTMLElement {
    tocEntries: HTMLAnchorElement[] = [];
    headings: HTMLElement[] = [];
    activeIndicator: HTMLElement | null = null;
    tocContent: HTMLElement | null = null;
    ticking = false;

    constructor() {
        super();
    }

    refreshTOC = () => {
        const buffer = document.getElementById('toc-data-buffer');
        this.tocContent = this.querySelector('#toc-content');
        this.activeIndicator = this.querySelector('#active-indicator');

        // 默认认为没有 TOC 数据
        let hasTOC = false;

        if (buffer && buffer.dataset.headings) {
            try {
                const headings = JSON.parse(buffer.dataset.headings);
                if (headings.length > 0) {
                    hasTOC = true;
                    const tocData = buildTocData(headings);
                    const newHtml = generateTocHTML(tocData);
                    if (this.tocContent) this.tocContent.innerHTML = newHtml;
                    this.init(); 
                } else {
                    if (this.tocContent) this.tocContent.innerHTML = '';
                }
            } catch (e) {
                console.error('Failed to update TOC', e);
            }
        } else {
            if (this.tocContent) this.tocContent.innerHTML = '';
        }

        this.toggleSidebarLayout(hasTOC);
    }

    // 核心修改：分离“布局位置”和“内容显示”的逻辑
    toggleSidebarLayout(hasTOC) {
        const tocCard = this.closest('.toc-card');
        const sidebarProfile = document.getElementById('sidebar-profile');
        const sidebarWidgets = document.getElementById('sidebar-widgets');
        const sidebar = document.getElementById('sidebar');

        // 1. 控制内容显示 (互斥)
        // 有 TOC 就只显 TOC；没有 TOC 就显 Profile/Widgets
        if (hasTOC) {
            if (tocCard) tocCard.style.display = 'block';
            if (sidebarProfile) sidebarProfile.style.display = 'none';
            if (sidebarWidgets) sidebarWidgets.style.display = 'none';
        } else {
            if (tocCard) tocCard.style.display = 'none';
            if (sidebarProfile) sidebarProfile.style.display = 'flex';
            if (sidebarWidgets) sidebarWidgets.style.display = 'flex';
        }

        // 2. 控制 Grid 位置 (主页置顶，其他置底)
        // 关键修复：不再依赖 hasTOC，而是依赖 URL
        const path = window.location.pathname.replace(/\/$/, '');
        const isHomePage = path === '' || path === '/index.html' || path === '/fuwari' || path === '/fuwari/index.html'; // 兼容可能的 base path

        if (isHomePage) {
            // 主页：Sidebar 在第一行
            if (sidebar) {
                sidebar.classList.remove('row-start-2');
                sidebar.classList.add('row-start-1');
            }
        } else {
            // 所有非主页 (文章/归档/关于)：Sidebar 在第二行
            if (sidebar) {
                sidebar.classList.remove('row-start-1');
                sidebar.classList.add('row-start-2');
            }
        }
    }

    updateActiveHeading = () => {
        const viewportHeight = window.innerHeight;
        const readingLine = 100;

        let activeIndex = -1;
        let maxVisibleIndex = -1;

        for (let i = this.headings.length - 1; i >= 0; i--) {
            const heading = this.headings[i];
            if (!heading) continue;
            
            const rect = heading.getBoundingClientRect();
            if (rect.top <= readingLine) {
                activeIndex = i;
                break;
            }
        }

        for (let i = 0; i < this.headings.length; i++) {
            const heading = this.headings[i];
            if (!heading) continue;
            
            const rect = heading.getBoundingClientRect();
            if (rect.top < viewportHeight) {
                maxVisibleIndex = i;
            }
        }

        let min = activeIndex;
        let max = maxVisibleIndex;

        if (min === -1 && this.headings.length > 0) min = 0;
        if (max < min) max = min;

        this.updateUI(min, max);
    }

    updateUI(min: number, max: number) {
        this.tocEntries.forEach((entry) => entry.classList.remove('active', 'text-[var(--primary)]', 'font-bold'));

        if (min !== -1 && max !== -1) {
            for (let i = min; i <= max; i++) {
                const entry = this.tocEntries[i];
                if (entry) entry.classList.add('active', 'text-[var(--primary)]', 'font-bold');
            }

            const minEntry = this.tocEntries[min];
            const maxEntry = this.tocEntries[max];

            if (this.activeIndicator && minEntry && maxEntry) {
                this.activeIndicator.classList.remove("hidden");
                const parent = this.activeIndicator.offsetParent;
                if (parent) {
                    const parentRect = parent.getBoundingClientRect();
                    const minRect = minEntry.getBoundingClientRect();
                    const maxRect = maxEntry.getBoundingClientRect();
                    
                    const top = minRect.top - parentRect.top;
                    const height = maxRect.bottom - minRect.top;
                    
                    this.activeIndicator.style.top = `${top}px`;
                    this.activeIndicator.style.height = `${height}px`;
                }
            }
        } else if (this.activeIndicator) {
            this.activeIndicator.classList.add("hidden");
        }
    }

    handleAnchorClick = (event: Event) => {};

    onScroll = () => {
        if (!this.ticking) {
            window.requestAnimationFrame(() => {
                this.updateActiveHeading();
                this.ticking = false;
            });
            this.ticking = true;
        }
    }

    init() {
        this.activeIndicator = this.querySelector("#active-indicator");
        this.tocEntries = Array.from(this.querySelectorAll<HTMLAnchorElement>("a[href^='#']"));

        if (this.tocEntries.length === 0) {
            if (this.activeIndicator) this.activeIndicator.classList.add('hidden');
            return;
        }

        this.headings = this.tocEntries.map(entry => {
            const id = decodeURIComponent(entry.hash?.substring(1));
            return document.getElementById(id);
        }).filter((h): h is HTMLElement => h instanceof HTMLElement);

        window.removeEventListener("scroll", this.onScroll);
        window.addEventListener("scroll", this.onScroll);
        this.addEventListener("click", this.handleAnchorClick);

        this.updateActiveHeading();
    };

    connectedCallback() {
        requestAnimationFrame(() => {
            this.init();
            const buffer = document.getElementById('toc-data-buffer');
            let hasData = false;
            if (buffer && buffer.dataset.headings) {
                hasData = JSON.parse(buffer.dataset.headings).length > 0;
            }
            this.toggleSidebarLayout(hasData);
        });
        
    const registerHooks = () => {
        // 再次检查 swup 是否存在，避免报错
        if (window.swup) {
            window.swup.hooks.on('content:replace', () => {
                this.refreshTOC();
            });
            
            // 补充：确保每次切换后重新计算一次激活状态，防止高亮滞后
            window.swup.hooks.on('content:replace', () => {
                 setTimeout(() => {
                    this.updateActiveHeading();
                 }, 100); // 稍微延迟，确保 DOM 渲染完毕
            });
        }
    };

    if (window.swup) {
        registerHooks();
    } else {
        document.addEventListener('swup:enable', registerHooks);
    }
    };

    disconnectedCallback() {
        window.removeEventListener("scroll", this.onScroll);
        this.removeEventListener("click", this.handleAnchorClick);
    };
}

if (!customElements.get("table-of-contents")) {
    customElements.define("table-of-contents", TableOfContents);
}
</script>